# -*- coding: utf-8 -*-
"""LSTM for price prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nG5WNmfUZkpCKLOxJJ6wcJNShuu_lFaf
"""

import math
import pandas_datareader as web
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler, StandardScaler
from keras.models import Sequential
from keras.layers import Dense, LSTM
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')

df = web.DataReader("INFY",data_source = "yahoo" , start = "2019-01-01",end='2021-05-05')

"""
plt.figure(figsize = (16,8))
plt.title("Closing Price")
plt.plot(df['Close']*75)
plt.xlabel("Date")
plt.ylabel("Closing Price")
plt.show()
"""

data = df.filter(['Close'])
dataset = data.values
training_len = math.ceil(len(dataset)*0.8)

scalar = MinMaxScaler(feature_range=(0,1))
scaled_data = scalar.fit_transform(dataset)

train_data = scaled_data[0:training_len,:]

x_train = []
y_train = []

for i in range(60,training_len):
    x_train.append(train_data[i-60:i,0])
    y_train.append(train_data[i,0])

x_train,y_train = np.array(x_train) , np.array(y_train)

# LSTM requires 3D array with dimensions [number of samples][time-step size][number of features]
x_train = np.reshape(x_train, (x_train.shape[0] , x_train.shape[1] , 1))

model = Sequential()
model.add(LSTM(50,return_sequences= True , input_shape = (x_train.shape[1],1)))
model.add(LSTM(50,return_sequences = False))
model.add(Dense(25))
model.add(Dense(1))

model.compile(optimizer = 'adam',loss = "mean_squared_error")

#training the model

test_data = scaled_data[training_len - 60:,:]

x_test = []
y_test = dataset[training_len:,:]

for i in range(60,len(test_data)):
    x_test.append(test_data[i - 60:i,0])

x_test = np.array(x_test)

x_test = np.reshape(x_test ,(x_test.shape[0],x_test.shape[1],1))


#model.fit returns a history object
history = model.fit(x_train,y_train,batch_size = 1,epochs = 5,validation_data = (x_test,y_test))


predictions = model.predict(x_test)
predictions = scalar.inverse_transform(predictions)

rmse = np.sqrt(np.mean((predictions - y_test) ** 2))

print(rmse)

#plotting accuracy and loss at each epoch
loss = history.history['loss']
val_loss = history.history['val_loss']
epochs = range(1,len(loss) + 1)
plt.plot(epochs,loss,'yellow',label = 'Training loss')
plt.plot(epochs,val_loss,'red',label = 'Validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
#plt.legend()
plt.show()

train = data[:training_len]
valid = data[training_len:]
valid['Predictions']  = predictions

plt.figure(figsize=(16,8))
plt.xlabel("Date")
plt.ylabel("Closing Price")
plt.plot(train['Close'])
plt.plot(valid['Close'])
plt.plot(valid['Predictions'])
plt.legend(['Train','Value','Predicted'],loc = "lower_right")
plt.show()

last = web.DataReader("INFY",data_source = "yahoo" , start = "2019-01-01",end='2021-05-10').filter(['Close'])[-60:].values

x_test = [scalar.fit_transform(last)]

x_test = np.array(x_test)


x_test = np.reshape(x_test ,(x_test.shape[0],x_test.shape[1],1))

predictions = model.predict(x_test)
predictions = scalar.inverse_transform(predictions)

predictions*73.45